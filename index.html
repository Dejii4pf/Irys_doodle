<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Irys Doodle</title>
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: row;
      height: 100vh;
      background-color: #f0f0f0;
    }
    h1 {
      margin: 10px 0;
      font-size: 1.5rem;
      text-align: center;
    }
    #toolbar {
      display: flex;
      flex-direction: column;
      gap: 10px;
      padding: 10px;
      background: #ffffff;
      border-right: 1px solid #ccc;
      align-items: center;
      min-width: 80px;
      flex-shrink: 0;
    }
    #center-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 3rem;
      font-weight: bold;
      color: rgba(0, 0, 0, 0.7);
      pointer-events: none; /* so it doesn't block canvas clicks */
      text-align: center;
    }
    canvas {
      border: 1px solid #ccc;
      background-color: white;
      margin: auto;
      display: block;
    }
    .sticky-note {
      position: absolute;
      background: yellow;
      padding: 10px;
      font-size: 14px;
      resize: both;
      overflow: auto;
    }
    .material-symbols-outlined {
      font-size: 24px;
      vertical-align: middle;
    }
    button.icon-btn {
      background: none;
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
    }
    #loader {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5em;
      background: white;
      padding: 20px;
      border: 2px solid #ccc;
      border-radius: 8px;
      z-index: 1000;
    }
    #onchain-link {
      margin: 10px;
      text-align: center;
    }
    .sticker {
      position: absolute;
      width: 100px;
      cursor: move;
    }

    /* three button that hides the toolbar when on mobile */
    .hamburger-btn {
      display: none;
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 5px;
      z-index: 1100;
      cursor: pointer;
    }

    @media (max-width: 768px) {
      body {
        flex-direction: column;
        height: auto;
      }
      #toolbar {
        display: none;
        flex-direction: column;
        min-width: unset;
        width: auto;
        max-height: auto;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 5px;
        background: white;
        position: absolute;
        top: 50px;
        left: 10px;
        z-index: 1000;
      }
      #toolbar.show {
        display: flex;
      }
      canvas {
        width: unset !important;
        height: unset !important;
        display: block;
      }
      .hamburger-btn {
        display: block;
      }
    }

    @media (max-width: 480px) {
      h1 {
        font-size: 1.2rem;
      }
      button.icon-btn {
        width: 32px;
        height: 32px;
        font-size: 16px;
      }
      #toolbar input[type="color"],
      #toolbar input[type="range"],
      #toolbar input[type="file"] {
        width: 50px;
        height: 28px;
      }
    }
  </style>
</head>
<body>
  
  <button id="hamburger" class="hamburger-btn">
    <span class="material-symbols-outlined">menu</span>
  </button>

  <div id="toolbar">
    <h1>Irys Doodle</h1>
    <button class="icon-btn" id="penBtn" title="Pen"><span class="material-symbols-outlined">edit</span></button>
    <button class="icon-btn" id="brushBtn" title="Brush"><span class="material-symbols-outlined">brush</span></button>
    <button class="icon-btn" id="eraserBtn" title="Eraser"><span class="material-symbols-outlined">ink_eraser</span></button>
    <button class="icon-btn" id="rectBtn" title="Rectangle"><span class="material-symbols-outlined">rectangle</span></button>
    <button class="icon-btn" id="circleBtn" title="Circle"><span class="material-symbols-outlined">circle</span></button>
    <button class="icon-btn" id="triangleBtn" title="Triangle"><span class="material-symbols-outlined">change_history</span></button>
    <button class="icon-btn" id="stickyNoteBtn" title="Add Sticky Note"><span class="material-symbols-outlined">sticky_note_2</span></button>
    <button class="icon-btn" id="addStickerBtn" title="Add Sticker"><span class="material-symbols-outlined">emoji_emotions</span></button>
    <input type="color" id="colorPicker" value="#000000">
    <input type="color" id="bgColorPicker" value="#ffffff">
    <input type="range" id="sizeSlider" min="1" max="50" value="5" title="Tool Size">
    <input type="file" id="uploadFile" />
    <button id="clearBtn">Clear All</button>
    <button id="saveBtn">Save</button>
    <button id="connectWalletBtn">Connect Wallet</button>
    <button id="saveOnChainBtn">Save On-Chain</button>
  </div>

    
  <div id="center-text"></div>
  <canvas id="canvas"></canvas>
  <div id="loader">Saving on-chain...</div>
  <div id="onchain-link"></div>

    <script src="https://cdn.jsdelivr.net/npm/@irys/sdk@latest/dist/web.bundle.min.js"></script>
    <script type="module">
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const sizeSlider = document.getElementById("sizeSlider");
    const colorPicker = document.getElementById("colorPicker");
    const bgColorPicker = document.getElementById("bgColorPicker");
    const uploadFile = document.getElementById("uploadFile");
    let drawing = false;
    let tool = "pen";
    let color = colorPicker.value;
    let bgColor = bgColorPicker.value;
    let startX, startY;
    let savedImageData;
    let isWalletConnected = false;
    let connectedAddress = null;
    let irys; // Declare globally
    const saveOnChainBtn = document.getElementById("saveOnChainBtn");
    saveOnChainBtn.disabled = true; // Disable by default

    window.addEventListener("DOMContentLoaded", () => {
      irys = new window.Irys({
        network: "mainnet", // or "testnet"
        token: "ethereum", // or "matic", "arbitrum", etc.
        wallet: window.ethereum, // Use MetaMask or other Web3 wallet
      });
    });

    // Example: Upload image data
    async function saveOnChain() {
      if (!irys) {
        alert("Irys SDK is not loaded yet. Please wait a moment and try again.");
        document.getElementById("loader").style.display = "none";
        return;
      }
      document.getElementById("loader").style.display = "block";
      try {
        // Get canvas data as blob
        const blob = await new Promise(resolve => canvas.toBlob(resolve, "image/png"));
        // Upload to Irys
        const receipt = await irys.upload(blob, { tags: [{name: "App", value: "Irys Doodle"}] });
        document.getElementById("onchain-link").innerHTML = 
        `<a href="https://irys.xyz/tx/${receipt.id}" target="_blank">View On-Chain</a>`;
      } catch (err) {
        alert("On-chain save failed: " + err.message);
      }
      document.getElementById("loader").style.display = "none";
    }

    function disconnectWallet() {
      isWalletConnected = false;
      connectedAddress = null;
      document.getElementById("connectWalletBtn").textContent = "Connect Wallet";
    }

    function setTool(t) {
      tool = t;
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = parseInt(sizeSlider.value);
    }
    window.setTool = setTool;

    function changeColor() {
      color = colorPicker.value;
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
    }

    function changeBackground() {
      bgColor = bgColorPicker.value;
      canvas.style.backgroundColor = bgColor;

      // Save current canvas as image
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // Fill with new background color
      ctx.save();
      ctx.globalCompositeOperation = "destination-over";
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Restore previous drawing (drawn above background)
      ctx.putImageData(imageData, 0, 0);
    }

    function addStickyNote() {
      const note = document.createElement("div");
      note.className = "sticky-note";
      note.style.left = "100px";
      note.style.top = "100px";

      // Create textarea for the note's content
      const textarea = document.createElement("textarea");
      textarea.style.width = "100px";
      textarea.style.height = "100px";

      // Create delete button
      const deleteBtn = document.createElement("button");
      deleteBtn.textContent = "âŒ";
      deleteBtn.style.position = "absolute";
      deleteBtn.style.top = "0";
      deleteBtn.style.right = "0";
      deleteBtn.style.background = "red";
      deleteBtn.style.color = "white";
      deleteBtn.style.border = "none";
      deleteBtn.style.cursor = "pointer";
      deleteBtn.style.fontSize = "12px";

      deleteBtn.onclick = () => note.remove();

      note.appendChild(deleteBtn);
      note.appendChild(textarea);
      document.body.appendChild(note);
      
      // Dragging logic
      note.addEventListener("mousedown", (e) => {
        if (e.target === deleteBtn) return; // Prevent drag when clicking delete
        let offsetX = e.offsetX;
        let offsetY = e.offsetY;

        function mouseMoveHandler(e) {
          note.style.left = e.pageX - offsetX + "px";
          note.style.top = e.pageY - offsetY + "px";
        }

        function mouseUpHandler() {
          document.removeEventListener("mousemove", mouseMoveHandler);
          document.removeEventListener("mouseup", mouseUpHandler);
        }

        document.addEventListener("mousemove", mouseMoveHandler);
        document.addEventListener("mouseup", mouseUpHandler);
      });

      // Dragging logic for mobile
      note.addEventListener("touchstart", (e) => {
        if (e.target === deleteBtn) return;
        const touch = e.touches[0];
        let offsetX = touch.clientX - note.offsetLeft;
        let offsetY = touch.clientY - note.offsetTop;

        function touchMoveHandler(e) {
          const moveTouch = e.touches[0];
          note.style.left = moveTouch.clientX - offsetX + "px";
          note.style.top = moveTouch.clientY - offsetY + "px";
        }

        function touchEndHandler() {
          document.removeEventListener("touchmove", touchMoveHandler);
          document.removeEventListener("touchend", touchEndHandler);
        }

        document.addEventListener("touchmove", touchMoveHandler);
        document.addEventListener("touchend", touchEndHandler);
      });
    }
    window.addStickyNote = addStickyNote;

    function addSticker() {
      const stickers = [
        "https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e3d8637-e1d6-4db5-9614-47b0a6b4bb34/irys-cat.png",
        "https://s3-us-west-2.amazonaws.com/secure.notion-static.com/57e1e28f-471e-4f32-8a80-f03b1a4fc3f3/irys-logo-pink.png"
      ];
      const url = stickers[Math.floor(Math.random() * stickers.length)];

      // Create wrapper div for sticker
      const wrapper = document.createElement("div");
      wrapper.className = "sticker";
      wrapper.style.position = "absolute";
      wrapper.style.left = "150px";
      wrapper.style.top = "150px";
      wrapper.style.width = "100px";
      wrapper.style.height = "100px";
      wrapper.style.cursor = "move";

      // Create img element
      const img = document.createElement("img");
      img.src = url;
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.pointerEvents = "none"; // Prevent drag on img itself

      wrapper.appendChild(img);
      document.body.appendChild(wrapper);

      // Mouse drag logic
      wrapper.addEventListener("mousedown", function (e) {
        let offsetX = e.offsetX;
        let offsetY = e.offsetY;

        function mouseMove(e) {
          wrapper.style.left = (e.pageX - offsetX) + "px";
          wrapper.style.top = (e.pageY - offsetY) + "px";
        }

        function stopMove() {
          document.removeEventListener("mousemove", mouseMove);
          document.removeEventListener("mouseup", stopMove);
        }

        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", stopMove);
      });

      // Dragging logic for mobile
      wrapper.addEventListener("touchstart", (e) => {
        const touch = e.touches[0];
        let offsetX = touch.clientX - note.offsetLeft;
        let offsetY = touch.clientY - note.offsetTop;

        function touchMoveHandler(e) {
          const moveTouch = e.touches[0];
          wrapper.style.left = moveTouch.clientX - offsetX + "px";
          wrapper.style.top = moveTouch.clientY - offsetY + "px";
        }

        function touchEndHandler() {
          document.removeEventListener("touchmove", touchMoveHandler);
          document.removeEventListener("touchend", touchEndHandler);
        }

        document.addEventListener("touchmove", touchMoveHandler);
        document.addEventListener("touchend", touchEndHandler);
      });
    }

    document.getElementById("addStickerBtn").onclick = addSticker;

    function uploadImage(event) {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = function (evt) {
        const wrapper = document.createElement("div");
        wrapper.style.position = "absolute";
        wrapper.style.left = "200px";
        wrapper.style.top = "200px";
        wrapper.style.width = "150px";
        wrapper.style.height = "150px";
        wrapper.style.resize = "both";
        wrapper.style.overflow = "auto";
        wrapper.style.border = "1px solid #ccc";
        wrapper.className = "sticker";

        const img = document.createElement("img");
        img.src = evt.target.result;
        img.style.width = "100%";
        img.style.height = "100%";
        img.style.pointerEvents = "none"; // Prevent drag on img itself

        wrapper.appendChild(img);
        document.body.appendChild(wrapper);

        // Drag logic for wrapper (mouse)
        wrapper.addEventListener("mousedown", function (e) {
          let offsetX = e.offsetX;
          let offsetY = e.offsetY;
          function mouseMove(e) {
            wrapper.style.left = (e.pageX - offsetX) + "px";
            wrapper.style.top = (e.pageY - offsetY) + "px";
          }
          function stopMove() {
            document.removeEventListener("mousemove", mouseMove);
            document.removeEventListener("mouseup", stopMove);
          }
          document.addEventListener("mousemove", mouseMove);
          document.addEventListener("mouseup", stopMove);
        });
        // Touch drag logic for wrapper (mobile)
        wrapper.addEventListener("touchstart", function (e) {
          const touch = e.touches[0];
          let offsetX = touch.clientX - wrapper.offsetLeft;
          let offsetY = touch.clientY - wrapper.offsetTop;

          function touchMoveHandler(e) {
            const moveTouch = e.touches[0];
            wrapper.style.left = moveTouch.clientX - offsetX + "px";
            wrapper.style.top = moveTouch.clientY - offsetY + "px";
          }

          function touchEndHandler() {
            document.removeEventListener("touchmove", touchMoveHandler);
            document.removeEventListener("touchend", touchEndHandler);
          }

          document.addEventListener("touchmove", touchMoveHandler);
          document.addEventListener("touchend", touchEndHandler);
        });
      };
      reader.readAsDataURL(file);
    }

    function resizeCanvas() {
      const width = Math.min(window.innerWidth - 100, 800);
      const height = Math.min(window.innerHeight - 40, 600);
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      changeBackground();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function flattenStickersToCanvas() {
      const canvasRect = canvas.getBoundingClientRect();
      document.querySelectorAll('.sticker'). forEach(wrapper => {
        const img = wrapper.querySelector('img');
        if (!img) return;
        // Get wrapper and size relative to canvas
        const wrapperRect = wrapper.getBoundingClientRect();
        const x = wrapperRect.left - canvasRect.left;
        const y = wrapperRect.top - canvasRect.top;
        const width = wrapper.offsetWidth;
        const height = wrapper.offsetHeight;
        ctx.drawImage(img, x, y, width, height);
      });
    }

    function saveCanvas() {
      flattenStickersToCanvas(); // <-- flatten stickers before saving
      const link = document.createElement("a");
      link.download = "irys_doodle.png";
      link.href = canvas.toDataURL();
      link.click();
    }

    function clearCanvasAndNotes() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      document.querySelectorAll('.sticky-note').forEach(note => note.remove());
      document.querySelectorAll('.sticker').forEach(sticker => sticker.remove());
    }

    async function connectWallet() {
      if (isWalletConnected) {
        disconnectWallet();
        return;
      }
      
      if (!window.ethereum) {
        alert("Install a Web3 wallet like MetaMask.");
        return;
      }

      try {
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        connectedAddress = accounts[0];
        const shortAddr = `${connectedAddress.slice(0,6)}...${connectedAddress.slice(-4)}`;
        document.getElementById("connectWalletBtn").textContent = shortAddr;
        isWalletConnected = true;
      } catch (err) {
        alert("Wallet connection failed: " + err.message);
      }
    }
    window.connectWallet = connectWallet;
    window.saveOnChain = saveOnChain;
    document.getElementById("penBtn").onclick = () => setTool("pen");
    document.getElementById("brushBtn").onclick = () => setTool("brush");
    document.getElementById("eraserBtn").onclick = () => setTool("eraser");
    document.getElementById("rectBtn").onclick = () => setTool("rect");
    document.getElementById("circleBtn").onclick = () => setTool("circle");
    document.getElementById("triangleBtn").onclick =() => setTool("triangle");
    document.getElementById("stickyNoteBtn").onclick = () => addStickyNote();
    colorPicker.onchange = changeColor;
    colorPicker.oninput = changeColor;
    bgColorPicker.oninput = changeBackground;
    bgColorPicker.onchange = changeBackground;
    uploadFile.onchange = uploadImage;
    document.getElementById("saveBtn").onclick = saveCanvas;
    document.getElementById("clearBtn").onclick = clearCanvasAndNotes;
    document.getElementById("connectWalletBtn").onclick = connectWallet;
    document.getElementById("saveOnChainBtn").onclick = saveOnChain;

    canvas.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const touch = e.touches [0];
      const rect = canvas.getBoundingClientRect();
      drawing = true;
      startX = touch.clientX - rect.left;
      startY = touch.clientY - rect.top;
      savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (["pen", "brush", "eraser"].includes(tool)) {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
      }
    });

    canvas.addEventListener("touchmove", (e) => {
      e.preventDefault();
      if (!drawing) return;
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      const size = parseInt(sizeSlider.value);

      if (tool === "pen") {
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.lineTo(x, y);
        ctx.stroke();
      } else if (tool === "brush") {
        ctx.lineWidth = size * 2;
        ctx.strokeStyle = color;
        ctx.lineTo(x, y);
        ctx.stroke();
      } else if (tool === "eraser") {
        ctx.lineWidth = size * 2;
        ctx.strokeStyle = bgColor;
        ctx.lineTo(x, y);
        ctx.stroke();
      } else if (["rect", "circle", "triangle"].includes(tool)) {
        ctx.putImageData(savedImageData, 0, 0);
        drawPreviewShape(x, y);
      }
    });

    canvas.addEventListener("touchend", (e) => {
      e.preventDefault();
      drawing = false;
      // You may want to handle shape finalization
    });

    canvas.addEventListener("mousedown", (e) => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      startX = e.clientX - rect.left;
      startY = e.clientY - rect.top;
      savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      if (["pen", "brush", "eraser"].includes(tool)) {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const size = parseInt(sizeSlider.value);

      if (tool === "pen") {
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        ctx.lineTo(x, y);
        ctx.stroke();
      } else if (tool === "brush") {
        ctx.lineWidth = size * 2;
        ctx.strokeStyle = color;
        ctx.lineTo(x, y);
        ctx.stroke();
      } else if (tool === "eraser") {
        ctx.lineWidth = size * 2;
        ctx.strokeStyle = bgColor;
        ctx.lineTo(x, y);
        ctx.stroke();
      } else if (["rect", "circle", "triangle"].includes(tool)) {
        ctx.putImageData(savedImageData, 0, 0);
        drawPreviewShape(x, y);
      }
    });

    canvas.addEventListener("mouseup", (e) => {
      drawing = false;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      if (tool === "rect") {
        ctx.strokeStyle = color;
        ctx.lineWidth = parseInt(sizeSlider.value);
        ctx.strokeRect(startX, startY, x - startX, y - startY);
      } else if (tool === "circle") {
        ctx.strokeStyle = color;
        ctx.lineWidth = parseInt(sizeSlider.value);
        const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
        ctx.beginPath();
        ctx.arc(startX, startY, radius, 0, Math.PI * 2);
        ctx.stroke();
      } else if (tool === "triangle") {
        ctx.strokeStyle = color;
        ctx.lineWidth = parseInt (sizeSlider.value);
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.lineTo(startX - (x - startX), y);
        ctx.closePath();
        ctx.stroke();
      }
    });

    function drawPreviewShape(x, y) {
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = parseInt(sizeSlider.value);
      if (tool === "rect") {
        ctx.strokeRect(startX, startY, x - startX, y - startY);
      } else if (tool === "circle") {
        const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
        ctx.arc(startX, startY, radius, 0, Math.PI * 2);
        ctx.stroke();
      } else if (tool === "triangle") {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.lineTo(startX - (x - startX), y);
        ctx.closePath();
        ctx.stroke();
      }
    }

    changeBackground();

    // Hamburger toggle
    const hamburger = document.getElementById("hamburger");
    const toolbar = document.getElementById("toolbar");
    hamburger.addEventListener("click", () => {
      toolbar.classList.toggle("show");
    });
  </script>
</body>
</html>
